# A distinct epigenetic profile distinguishes stenotic from non-inflamed fibroblasts in the ileal mucosa of Crohn’s disease patients

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("genefilter")

BiocManager::install("ashr")
library("ashr")

library(SummarizedExperiment)
library(ggplot2)
library("pheatmap")
library("RColorBrewer")
library(clusterProfiler)
library(org.Hs.eg.db)
library(fdrtool)
library(DESeq2)
library("genefilter")
library(limma)

setwd("C:/Users/122002/Desktop/VERONA/Programming_for_bioinf/RNA_analysisCrohn/data/GENDX000019")

#Load the gene expression matrix
df <- read.delim("GENDX000019_GeneMatrix_rawCounts.txt", row.names=1)

#Load the metadata and delete the non useful columns
metadata <- read.delim("GEND000019-meta.txt", row.names=5)
# met<- as.data.frame(lapply(met, as.factor))


# Remove features that do not have sufficient reads
df1 <- df[rowSums(df>1) >= 11,]
genes <- row.names(df1)

df1<- as.data.frame(lapply(df1, as.integer))

#Set as rownames only the Ensembl IDs (cutting the part of gene names)
row.names(df1) <- substr(genes, 1, 15)

#metadata$Age <- as.factor(metadata$Age)
metadata$Age.Level <-  cut(metadata$Age, c(17, 40, 80))


#DESeq

#INTRA
dds1 <- DESeqDataSetFromMatrix(df1, colData=metadata, design = ~ Gender + Age.Level + Development.Stage + Disease)

# log
rld1 <- rlog(dds1, blind=FALSE)

#PCA: La PCA (Principal Component Analysis) è una tecnica di analisi statistica multivariata che mira a identificare i fattori principali (o le componenti principali) che spiegano la maggior parte della varianza dei dati. In pratica, la PCA cerca di trovare un set di nuove variabili che siano una combinazione lineare dei dati originali, in modo che la prima nuova variabile spieghi la massima varianza possibile, la seconda spieghi la massima varianza rimanente, e così via. I valori PC1 e PC2, nel grafico della PCA, sono i valori delle prime due componenti principali, ovvero le due variabili lineari che spiegano la maggior parte della varianza dei dati. Essi sono visualizzati come un grafico a dispersione bidimensionale, dove ogni punto rappresenta una osservazione (ad esempio, un campione di dati), e le coordinate di ogni punto corrispondono ai suoi valori per le componenti principali PC1 e PC2. Questo tipo di grafico è utile per visualizzare le relazioni tra le o osservazioni e per individuare eventuali pattern o cluster nei dati.

#DOMANDA: riusciamo a ricavare la combinazione lineare che lui usa delle variabili?
plotPCA(rld1, intgroup = c("Age.Level")) 
plotPCA(rld1, intgroup = c("Disease"))
plotPCA(rld1, intgroup = c("Disease", "Disease.State"))
plotPCA(rld1, intgroup = c("Gender", "Disease"))
plotPCA(rld1, intgroup = c("Age.Level", "Disease"))

#DESeq
dds1 <- DESeq(dds1)

res1<-results(dds1)

summary(res1)

# Show the significant genes with the strongest down or up regulation
resSig1 <- subset(res1, padj < 0.1)
resSig1 <- resSig1[order(resSig1$log2FoldChange, decreasing=T), ]
head(resSig1)
#RIPROVA CON UN NUOVO padj<0.05

# Show significant effects of treatment on gene counts more than doubling or less than halfing
resLFC1 <- results(dds1, lfcThreshold=1)
table(resLFC1$padj < 0.1)

#PLOT RESULTS:
topGenes1<-rownames(res1[order(res1$padj),])
plotCounts(dds1, gene=topGenes1[1], intgroup=c("Disease"))

plotCounts(dds1, gene=topGenes1[2], intgroup=c("Disease"))
#no

plotCounts(dds1, gene=topGenes1[3], intgroup=c("Disease"))
#no

plotCounts(dds1, gene=topGenes1[4], intgroup=c("Disease"))
#no

plotCounts(dds1, gene=topGenes1[5], intgroup=c("Disease"))
#ok

plotCounts(dds1, gene=topGenes1[6], intgroup=c("Disease"))
#ok

plotCounts(dds1, gene=topGenes1[7], intgroup=c("Disease"))
#ok

#PLOT CON DISEASE.STATE:
geneCounts1 <- plotCounts(dds1, gene=topGenes1[1], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts1, aes(x=Disease.State, y=count, color= Disease.State)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)

geneCounts1 <- plotCounts(dds1, gene=topGenes1[2], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts1, aes(x=Disease.State, y=count, color= Disease.State)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)

geneCounts1 <- plotCounts(dds1, gene=topGenes1[3], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts1, aes(x=Disease.State, y=count, color= Disease.State)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)

geneCounts1 <- plotCounts(dds1, gene=topGenes1[4], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts1, aes(x=Disease.State, y=count, color= Disease.State)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)

geneCounts1 <- plotCounts(dds1, gene=topGenes1[5], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts1, aes(x=Disease.State, y=count, color= Disease.State)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)

geneCounts1 <- plotCounts(dds1, gene=topGenes1[6], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts1, aes(x=Disease.State, y=count, color= Disease.State)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)


#PLOT MA: CHIEDI
#Il grafico di plotMA in R è utilizzato per visualizzare i risultati dell'analisi di espressione genica differenziale tra due condizioni sperimentali. Il grafico rappresenta l'andamento del rapporto di espressione tra le due condizioni (log fold change) in funzione dell'abbondanza di espressione media tra le due condizioni (media degli intensità di segnale) sono basati su informazioni che sono teoricamente equivalenti tra le due condizioni sperimentali. In altre parole, non ci dovrebbe essere un'influenza sistematica della media degli intensità di segnale su log fold change. Pertanto, in un esperimento di espressione genica differenziale ben progettato, ci si aspetta che il grafico di plotMA sia simmetrico intorno all'asse orizzontale che rappresenta il valore di log fold change = 0. Una deviazione da questa simmetria potrebbe indicare la presenza di effetti sistematici o di bias nell'esperimento.

resultsNames(dds1)
resprova1 <- results(dds1, contrast = list("Disease_Healthy.Control_vs_Crohn.s.Disease" ))
plotMA(resprova1, ylim=c(-5,5))

resprova2 <- results(dds1, contrast = list("Gender_male_vs_female"))
plotMA(resprova2, ylim=c(-5,5))


resprova3 <- results(dds1, contrast = list("Age.Level_.40.80._vs_.17.40."))
plotMA(resprova3, ylim=c(-5,5))


#HISTOGRAM OF PVALUES DISTRIBUTION:
hist(res1$pvalue[res1$baseMean > 1], breaks=0:20/20, col="royalblue4", border="white")

#PVALUE CORRECTION:
# remove filtered out genes by independent filtering,
# they have NA adj. pvals
res1 <- res1[ !is.na(res1$padj),] 

# remove genes with NA pvals (outliers)
res1 <- res1[ !is.na(res1$pvalue), ]

# remove adjsuted pvalues, since we add the fdrtool results later on
res1 <- res1[, -which(names(res1) == "padj")]

# use z-scores as input to FDRtool to re-estimate the p-value
res_fdr1 <- fdrtool(res1$stat, statistic= "normal", plot = T)

# add values to the results data frame, also ad new BH- adjusted p-values
res1[,"padj"] <- p.adjust(res_fdr1$pval, method = "BH")

# plot correct p-value distribution 
hist(res_fdr1$pval, col = "royalblue4", xlab = "CORRECTED p-values", border="white")

#GENE CLUSTERING and HEATMAP: chiedi
topVarGenes1 <- head(order(rowVars(assay(rld1)),decreasing=TRUE),20) 
#rowVars takes the variance of each gene  among the samples, in each row.

mat1 <- assay(rld1)[topVarGenes1, ]
mat1 <- mat1 - rowMeans(mat1)
#to normalize

new_mat1 <- removeBatchEffect(mat1, batch= colData(rld1)$Gender) 

#heatmap with both Gender and Disease clusters
df_clust1 <- as.data.frame(colData(rld1)[,c("Gender","Disease")])
pheatmap(mat1, annotation_col=df_clust1)
#heatmap without Batch Effect
pheatmap(new_mat1, annotation_col=df_clust1)


#Enrichment
geneList_DESeq1 <- resSig1$log2FoldChange
names(geneList_DESeq1) <- rownames(resSig1)

#Gene Ontology (GO)
#ALL
ego1ALL <- enrichGO(gene = names(geneList_DESeq1), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "ALL", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)
                
head(ego1ALL)  

#Molecular Function (top)
ego1MF <- enrichGO(gene = names(geneList_DESeq1), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "MF", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)

head(ego1MF)
goplot(ego1MF)

#Cellular Components
ego1CC <- enrichGO(gene = names(geneList_DESeq1), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "CC", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)
                
head(ego1CC)
goplot(ego1CC)

#Biological Process
ego1BP <- enrichGO(gene = names(geneList_DESeq1), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "BP", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)

head(ego1BP)
goplot(ego1BP)


# Kyoto Encyclopedia of Genes and Genomes (KEGG)
# Convert ENSEMBL in ENTREZID
resSig1_KEGG <- subset(res1, padj < 0.8)
resSig1_KEGG <- resSig1_KEGG[order(resSig1_KEGG$log2FoldChange, decreasing=T), ]

geneList_DESeq1_1 <- resSig1_KEGG$log2FoldChange
names(geneList_DESeq1_1) <- row.names(resSig1_KEGG)

gene_df1 <- bitr(names(geneList_DESeq1_1), fromType = "ENSEMBL", toType = "ENTREZID", 
                OrgDb = org.Hs.eg.db)
                
geneList_df1 <- resSig1_KEGG$log2FoldChange    
names(geneList_df1) <- gene_df1$ENTREZID

#kk1 <- gseKEGG(geneList     = geneList_df1, organism = 'hsa', minGSSize = 1,
#               pvalueCutoff = 0.1, pAdjustMethod = "BH", verbose = FALSE)

kk1 <- enrichKEGG(gene = gene_df1$ENTREZID, organism = 'hsa', pvalueCutoff = 0.1)

head(kk1)
browseKEGG(kk1, "hsa04630")


#---------------------------------------------------------------------------------------------------------------

metadata$Disease.State <- as.factor(metadata$Disease.State)
metadata$Disease.State <- relevel(metadata$Disease.State, "non-inflamed")


#INTER
dds2 <- DESeqDataSetFromMatrix(df1, colData=metadata, design = ~ Gender + Age.Level  + Development.Stage + Disease.State)

# log
rld2 <- rlog(dds2, blind=FALSE)

# No plot changes according to different designs
plotPCA(rld2, intgroup = c("Gender"))
plotPCA(rld2, intgroup = c("Age.Level")) 
plotPCA(rld2, intgroup = c("Disease"))
plotPCA(rld2, intgroup = c("Disease", "Disease.State"))
plotPCA(rld2, intgroup = c("Gender", "Disease"))
plotPCA(rld2, intgroup = c("Age.Level", "Disease"))

#DESeq
dds2 <- DESeq(dds2)

res2<-results(dds2)
summary(res2)

# Show the significant genes with the strongest down or up regulation
resSig2 <- subset(res2, padj < 0.1)
resSig2 <- resSig2[order(resSig2$log2FoldChange, decreasing=T), ]
head(resSig2)

#SHRINKAGE
#INF vs NINF
res2_inf_noninf <- lfcShrink(dds2, coef="Disease.State_inflamed_vs_non.inflamed", type="normal")

res2_inf_noninf <- subset(res2_inf_noninf, padj < 0.1)
res2_inf_noninf <- res2_inf_noninf[order(res2_inf_noninf$log2FoldChange, decreasing=T), ]
head(res2_inf_noninf)

#STEN vs NINF
res2_sten_noninf <- lfcShrink(dds2, coef = "Disease.State_stenotic_vs_non.inflamed", type = "normal")

res2_sten_noninf <- subset(res2_sten_noninf, padj < 0.1)
res2_sten_noninf <- res2_sten_noninf[order(res2_sten_noninf$log2FoldChange, decreasing=T), ]
head(res2_sten_noninf)

#STEN vs INF
# We need to relevel Disease.State
metadata$Disease.State1 <- as.factor(metadata$Disease.State)
metadata$Disease.State1 <- relevel(metadata$Disease.State, "inflamed")

dds2_SI <- DESeqDataSetFromMatrix(df1, colData=metadata, design = ~ Gender + Age.Level  + Development.Stage + Disease.State1)

# log
rld2_SI <- rlog(dds2_SI, blind=FALSE)

#DESeq
dds2_SI <- DESeq(dds2_SI)

res2_sten_inf <- lfcShrink(dds2_SI, coef = "Disease.State1_stenotic_vs_inflamed", type = "normal")

res2_sten_inf <- subset(res2_sten_inf, padj < 0.1)
res2_sten_inf <- res2_sten_inf[order(res2_sten_inf$log2FoldChange, decreasing=T), ]
head(res2_sten_inf)


# Show significant effects of treatment on gene counts more than doubling or less than halfing: DA NON FARE, non ci sono geni che sono doppiamente espressi in una condizione rispetto un'altra
resLFC2 <- results(dds2, lfcThreshold=1)
table(resLFC2$padj < 0.1)


#PLOT RESULTS CON DISEASE.STATE:
#INF vs NINF
topGenes2_IN<-rownames(res2_inf_noninf[order(res2_inf_noninf$padj),])
geneCounts2_IN <- plotCounts(dds2, gene=topGenes2_IN[1], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts2_IN, aes(x=Disease.State, y=count, fill=Disease.State)) +
  scale_y_log10() + 
  geom_dotplot(binaxis="y", stackdir="center")

#STEN vs NINF
topGenes2_SN<-rownames(res2_sten_noninf[order(res2_sten_noninf$padj),])
geneCounts2_SN <- plotCounts(dds2, gene=topGenes2_SN[1], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts2_SN, aes(x=Disease.State, y=count, fill=Disease.State)) +
  scale_y_log10() + 
  geom_dotplot(binaxis="y", stackdir="center")


#STEN vs INF
topGenes2_SI<-rownames(res2_sten_inf[order(res2_sten_inf$padj),])
geneCounts2_SI <- plotCounts(dds2_SI, gene=topGenes2_SI[1], intgroup=c("Disease.State"), returnData=T)
ggplot(geneCounts2_SI, aes(x=Disease.State, y=count, fill=Disease.State)) +
  scale_y_log10() + 
  geom_dotplot(binaxis="y", stackdir="center")


#PLOT MA:
#INF vs NINF
res2_IN <- results(dds2, contrast = list("Disease.State_inflamed_vs_non.inflamed"))
DESeq2::plotMA(res2_IN)

#STEN vs NINF
res2_SN <- results(dds2, contrast = list("Disease.State_stenotic_vs_non.inflamed"))
DESeq2::plotMA(res2_SN)

#STEN vs INF
res2_SI <- results(dds2_SI, contrast = list("Disease.State1_stenotic_vs_inflamed"))
DESeq2::plotMA(res2_SI)


#HISTOGRAM OF PVALUES DISTRIBUTION:
#INF vs NINF
hist(res2_IN$pvalue[res2_IN$baseMean > 1], breaks=0:20/20, col="royalblue4", border="white", main = "INF vs NINF", xlab = "p-values")

#PVALUE CORRECTION:
# remove filtered out genes by independent filtering,
# they have NA adj. pvals
res2_IN <- res2_IN[ !is.na(res2_IN$padj),] 
# remove genes with NA pvals (outliers)
res2_IN <- res2_IN[ !is.na(res2_IN$pvalue), ]
# remove adjsuted pvalues, since we add the fdrtool results later on
res2_IN <- res2_IN[, -which(names(res2_IN) == "padj")]

# use z-scores as input to FDRtool to re-estimate the p-value
res_fdr2_IN <- fdrtool(res2_IN$stat, statistic= "normal", plot = F)

# add values to the results data frame, also ad new BH- adjusted p-values
res2_IN[,"padj"] <- p.adjust(res_fdr2_IN$pval, method = "BH")

# plot correct p-value distribution 
hist(res_fdr2_IN$pval, col = "royalblue4", main = "INF vs NINF", xlab = "CORRECTED p-values", border="white")

#STEN vs NINF
hist(res2_SN$pvalue[res2_SN$baseMean > 1], breaks=0:20/20, col="royalblue4", border="white", main = "STEN vs NINF", xlab = "p-values")
#PVALUE CORRECTION:
res2_SN <- res2_SN[ !is.na(res2_SN$padj),] 
res2_SN <- res2_SN[ !is.na(res2_SN$pvalue), ]
res2_SN <- res2_SN[, -which(names(res2_SN) == "padj")]
res_fdr2_SN <- fdrtool(res2_SN$stat, statistic= "normal", plot = F)
res2_SN[,"padj"] <- p.adjust(res_fdr2_SN$pval, method = "BH")

hist(res_fdr2_SN$pval, col = "royalblue4", main = "STEN vs NINF", xlab = "CORRECTED p-values", border="white")

#STEN vs INF
hist(res2_SI$pvalue[res2_SI$baseMean > 1], breaks=0:20/20, col="royalblue4", border="white", main = "STEN vs INF", xlab = "p-values")
#PVALUE CORRECTION:
res2_SI <- res2_SI[ !is.na(res2_SI$padj),] 
res2_SI <- res2_SI[ !is.na(res2_SI$pvalue), ]
res2_SI <- res2_SI[, -which(names(res2_SI) == "padj")]
res_fdr2_SI <- fdrtool(res2_SI$stat, statistic= "normal", plot = F)
res2_SI[,"padj"] <- p.adjust(res_fdr2_SI$pval, method = "BH")

hist(res_fdr2_SI$pval, col = "royalblue4", main = "STEN vs INF", xlab = "CORRECTED p-values", border="white")

#GENE CLUSTERING and HEATMAP:
topVarGenes2 <- head(order(rowVars(assay(rld2)),decreasing=TRUE),20) 
#rowVars takes the variance of each gene  among the samples, in each row.
mat2 <- assay(rld2)[topVarGenes2, ]
mat2 <- mat2 - rowMeans(mat2)
#to normalize
new_mat2 <- removeBatchEffect(mat2, batch= colData(rld2)$Gender) 

#heatmap with both Gender and Disease clusters
df_clust2 <- as.data.frame(colData(rld2)[,c("Gender","Disease.State")])
pheatmap(new_mat2, annotation_col=df_clust2)

#referring to INF
topVarGenes2_SI <- head(order(rowVars(assay(rld2_SI)),decreasing=TRUE),20) 
#rowVars takes the variance of each gene  among the samples, in each row.
mat2_SI <- assay(rld2_SI)[topVarGenes2_SI, ]
mat2_SI <- mat2_SI - rowMeans(mat2_SI)
#to normalize
new_mat2_SI <- removeBatchEffect(mat2_SI, batch= colData(rld2_SI)$Gender) 

#heatmap with both Gender and Disease clusters
df_clust2_SI <- as.data.frame(colData(rld2_SI)[,c("Gender","Disease.State")])
pheatmap(new_mat2_SI, annotation_col=df_clust2_SI)


#Enrichment
geneList_DESeq2 <- resSig2$log2FoldChange
names(geneList_DESeq2) <- rownames(resSig2)

#Gene Ontology (GO)
#ALL
ego2ALL <- enrichGO(gene = names(geneList_DESeq2), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "ALL", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)
                
head(ego2ALL)  

#Molecular Function (top)
ego2MF <- enrichGO(gene = names(geneList_DESeq2), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "MF", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)

head(ego2MF)
goplot(ego2MF)

#Cellular Components
ego2CC <- enrichGO(gene = names(geneList_DESeq2), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "CC", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)
                
head(ego2CC)
goplot(ego2CC)

#Biological Process
ego2BP <- enrichGO(gene = names(geneList_DESeq2), OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL',
                ont = "BP", pAdjustMethod = "BH", pvalueCutoff  = 0.1, 
                readable = T)

head(ego2BP)
goplot(ego2BP)


# Kyoto Encyclopedia of Genes and Genomes (KEGG)
# Convert ENSEMBL in ENTREZID

gene_df2 <- bitr(names(geneList_DESeq2), fromType = "ENSEMBL", toType = "ENTREZID", 
                OrgDb = org.Hs.eg.db)
                
geneList_df2 <- resSig2$log2FoldChange    
names(geneList_df2) <- gene_df2$ENTREZID

kk2 <- gseKEGG(geneList     = geneList_df2, organism = 'hsa', minGSSize = 120,
               pvalueCutoff = 0.1, pAdjustMethod = "BH", verbose = FALSE)

kk2 <- enrichKEGG(gene = gene_df2$ENTREZID, organism = 'hsa', pvalueCutoff = 0.1)

head(kk2)


#---------------------------------------------------------------------------------------------------------------

#ALL
dds3 <- DESeqDataSetFromMatrix(df1, colData=metadata, design = ~ Gender + Age.Level + Development.Stage + Disease.State + Gender:Disease.State)

# log
rld3 <- rlog(dds3, blind=FALSE)

# No plot changes according to different designs
plotPCA(rld3, intgroup = c("Gender"))
plotPCA(rld3, intgroup = c("Age.Level")) 
plotPCA(rld3, intgroup = c("Disease"))
plotPCA(rld3, intgroup = c("Disease", "Disease.State"))
plotPCA(rld3, intgroup = c("Gender", "Disease"))
plotPCA(rld3, intgroup = c("Age.Level", "Disease"))


dds3 <- DESeq(dds3)

res3<-results(dds3)

summary(res3)


# Show the significant genes with the strongest down or up regulation
resSig3 <- subset(res3, padj < 0.1)
resSig3 <- resSig3[order(resSig3$log2FoldChange, decreasing=T), ]
head(resSig3)


# Show significant effects of treatment on gene counts more than doubling or less than halfing
resLFC3 <- results(dds3, lfcThreshold=1)
table(resLFC3$padj < 0.1)


#PLOT RESULTS CON DISEASE.STATE:
topGenes3<-rownames(res3[order(res3$padj),])
plotCounts(dds3, gene=topGenes3[1], intgroup=c("Disease.State"))
# Stenotic differentially expressed w.r.t other groups

plotCounts(dds3, gene=topGenes3[2], intgroup=c("Disease.State"))
#no

plotCounts(dds3, gene=topGenes3[3], intgroup=c("Disease.State"))
# Stenotic differentially expressed w.r.t other groups


#PLOT CON DISEASE:
geneCounts3 <- plotCounts(dds3, gene=topGenes3[1], intgroup=c("Disease"), returnData=T)
ggplot(geneCounts3, aes(x=Disease, y=count, color= Disease)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)
# No differences

geneCounts3 <- plotCounts(dds3, gene=topGenes3[2], intgroup=c("Disease"), returnData=T)
ggplot(geneCounts3, aes(x=Disease, y=count, color= Disease)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)
# Good
  
geneCounts3 <- plotCounts(dds3, gene=topGenes3[3], intgroup=c("Disease"), returnData=T)
ggplot(geneCounts3, aes(x=Disease, y=count, color= Disease)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)
# No
  
geneCounts3 <- plotCounts(dds3, gene=topGenes3[4], intgroup=c("Disease"), returnData=T)
ggplot(geneCounts3, aes(x=Disease, y=count, color= Disease)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)
  
geneCounts3 <- plotCounts(dds3, gene=topGenes3[5], intgroup=c("Disease"), returnData=T)
ggplot(geneCounts3, aes(x=Disease, y=count, color= Disease)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)
  
geneCounts3 <- plotCounts(dds3, gene=topGenes3[6], intgroup=c("Disease"), returnData=T)
ggplot(geneCounts3, aes(x=Disease, y=count, color= Disease)) +
  scale_y_log10() + geom_point(position=position_jitter(width=.1,height=0), size=3)
  

#PLOT MA:
resultsNames(dds3)
resprova1 <- results(dds3, contrast = list("Gendermale.Disease.Statestenotic"))
plotMA(resprova1, ylim=c(-5,5))

resprova2 <- results(dds3, contrast = list("Gendermale.Disease.Stateinflamed"))
plotMA(resprova2, ylim=c(-5,5))


resprova3 <- results(dds3, contrast = list("Gendermale.Disease.Statenon.inflamed"))
plotMA(resprova3, ylim=c(-5,5))


#HISTOGRAM OF PVALUES DISTRIBUTION:
hist(res3$pvalue[res3$baseMean > 1], breaks=0:20/20, col="royalblue4", border="white")

#PVALUE CORRECTION:

# remove filtered out genes by independent filtering,
# they have NA adj. pvals
res3 <- res3[ !is.na(res3$padj),] 
# remove genes with NA pvals (outliers)
res3 <- res3[ !is.na(res3$pvalue), ]
# remove adjsuted pvalues, since we add the fdrtool results later on
res3 <- res3[, -which(names(res3) == "padj")]

# use z-scores as input to FDRtool to re-estimate the p-value
res_fdr3 <- fdrtool(res3$stat, statistic= "normal", plot = T)

# add values to the results data frame, also ad new BH- adjusted p-values
res3[,"padj"] <- p.adjust(res_fdr3$pval, method = "BH")

# plot correct p-value distribution 
hist(res_fdr3$pval, col = "royalblue4", xlab = "CORRECTED p-values", border="white")

#GENE CLUSTERING:
topVarGenes3 <- head(order(rowVars(assay(rld3)),decreasing=TRUE),20) #rowVars takes the variance of each gene  among the samples, in each row.

mat3 <- assay(rld3)[topVarGenes3, ]
mat3 <- mat3 - rowMeans(mat3)
df_clust3 <- as.data.frame(colData(rld3)[,c("Disease.State","Gender")])
pheatmap(mat3, annotation_col=df_clust3)

#EXPORTING RESULTS:
#resOrderedDF <- as.data.frame(res)[1:100,]
#write.csv(resOrderedDF, file="results.csv")

        



